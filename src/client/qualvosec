#!/usr/bin/env python3

# QualvoSec
# QualvoSec is a minimalistic security patch management tool for unattended
# upgrades on Linux and BSD based systems that are obtaining their packages
# from a distribution based repository.
# Copyright (C) 2023 Florian Paul Azim Hoberg @gyptazy <gyptazy@gyptazy.ch>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import argparse
import configparser
import datetime
import logging
import os
import socket
import subprocess
import sys
import time
import threading
import urllib
try:
    import yaml
except ImportError as error:
        logging.critical('QualvoSec: Can not start QualvoSec. Missing Python module: yaml')
        sys.exit(2)
from urllib.request import urlretrieve
try:
    from http.server import HTTPServer, BaseHTTPRequestHandler
except ImportError as error:
    logging.critical('QualvoSec: Can not start monitoring endpoint. Missing Python module: http')
    sys.exit(2)


# Constants
__appname__ = "QualvoSec"
__version__ = "1.0.2"
__author__  = "Florian Paul Azim Hoberg <gyptazy@gyptazy.ch> @gyptazy"


## Classes
# Logging class
class SystemdHandler(logging.Handler):
    """ Class to handle logging options. """
    PREFIX = {
        logging.CRITICAL: "<2> " + __appname__ + ": ",
        logging.ERROR: "<3> " + __appname__ + ": ",
        logging.WARNING: "<4> " + __appname__ + ": ",
        logging.INFO: "<6> " + __appname__ + ": ",
        logging.DEBUG: "<7> " + __appname__ + ": ",
        logging.NOTSET: "<7 " + __appname__ + ": ",
    }

    def __init__(self, stream=sys.stdout):
        self.stream = stream
        logging.Handler.__init__(self)

    def emit(self, record):
        try:
            msg = self.PREFIX[record.levelno] + self.format(record) + "\n"
            self.stream.write(msg)
            self.stream.flush()
        except Exception:
            self.handleError(record)

# Monitoring class
class MonitoringHandler(BaseHTTPRequestHandler):
    """ Class to respond for monitoring requests on QualvoSec. """
    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b'healthy=true')


## Functions
def initialize_args():
    """ Initialize given arguments for QualvoSec. """
    argparser = argparse.ArgumentParser(description='QualvoSec')
    argparser.add_argument('-c', '--config', type=str, help='Path to config file.')
    return argparser.parse_args()


def initialize_config_path(app_args):
    """ Initialize path to config file. """
    config_path = app_args.config
    if app_args.config is None:
        # Try to fallback on distribution default path.
        config_path = '/etc/qualvosec/qualvosec.conf'
    return config_path


def initialize_config_options(config_path):
    """ Read configuration from given config file for QualvoSec. """
    try:
        config = configparser.ConfigParser()
        config.read(config_path)
        server = config['general']['server']
        monitoring = config['general']['monitoring']
        monitoring_port = config['general']['monitoring_port']
        log_level = config['general']['log_level']
        log_handler = config['general']['log_handler']
    except configparser.NoSectionError:
        logging.critical('Error parsing config file: Section not found.')
        sys.exit(2)
    except configparser.ParsingError:
        logging.critical('Error parsing config file: Impossible to parse file.')
        sys.exit(2)
    except KeyError:
        logging.critical('Error parsing config file: Key/Value not found.')
        sys.exit(2)
    return server, log_level, log_handler, monitoring, monitoring_port


def initialize_logger(log_level, log_handler):
    """ Initialize desired logging handler. """
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)
    root_logger.addHandler(SystemdHandler())
    logging.info(f'Info: Logger initialized.')


def initialize_monitoring():
    """ Initialize monitoring status endpoint. """
    logging.info(f'Info: Initializing monitoring endpoint on port tcp/{monitoring_port}.')
    httpd = HTTPServer(('localhost', int(monitoring_port)), MonitoringHandler)
    httpd.serve_forever()


def fetch_qualvosec_manifest(server, qualvosec_manifest_path, system_fqdn):
    """ Fetch the QualvoSec manifest from the remote server. """
    # Customize urllib opener.
    opener = urllib.request.build_opener()
    opener.addheaders = [('User-agent', f'{__appname__} {__version__} {system_fqdn}')]

    # Grab the initial QualvoSec manifest file once.
    urllib.request.install_opener(opener)
    if qualvosec_manifest_path is None:
        logging.info(f'Info: Trying to fetch manifest from {server}.')
        try:
            return urlretrieve(f'{server}/patch.yaml')
        except urllib.error.URLError:
            logging.critical(f'Error while fetching the manifest from {server}.')
            sys.exit(2)
    # Validate the file age for caching. Cache it during the runtime
    # and update the content every 6 hours.
    else:
        manifest_file_age = _get_file_age_time(qualvosec_manifest_path[0])
        if int(manifest_file_age) > 360:
            logging.info(f'Info: Trying to fetch manifest from {server}.')
            try:
                return urlretrieve(f'{server}/patch.yaml')
            except urllib.error.URLError:
                logging.critical(f'Error while fetching the manifest from {server}.')
                sys.exit(2)
        else:
            logging.info(f'Info: Cached manifest from {server} used.')
            return qualvosec_manifest_path


def read_qualvosec_manifest(qualvosec_manifest_path):
    """ Read the QualvoSec patch manifest. """
    logging.info(f'Info: Reading manifest file from {qualvosec_manifest_path}')
    with open(qualvosec_manifest_path, 'r') as test:
        qualvosec_manifest = yaml.safe_load(test)
    return qualvosec_manifest


def get_system_fqdn():
    """ Get the system's local fqdn. """
    logging.info(f'Info: Getting system fqdn.')
    return socket.getfqdn()


def _get_file_age_time(file_name):
    """ Get the file age time of a given file. """
    logging.info(f'Info: Getting file age time.')
    return time.time() - os.path.getmtime(file_name)


def _get_time_information_now():
    """ Get the current local time information. """
    logging.info(f'Info: Getting current time information.')
    return datetime.datetime.now().weekday(), datetime.datetime.now().hour, datetime.datetime.now().minute


def _get_time_information_patch(system_fqdn, qualvosec_manifest):
    """ Get the time information from QualvoSec manifest. """
    logging.info(f'Info: Getting manifest time information.')
    return qualvosec_manifest[system_fqdn]['weekday'], qualvosec_manifest[system_fqdn]['hour'], qualvosec_manifest[system_fqdn]['minute']


def _get_system_os_pkg_mgr(system_fqdn):
    """ Get the system's operating system package manager. """
    system_os = None
    system_os_debian  = '/bin/apt'
    system_os_redhat  = '/bin/rpm'
    system_os_freebsd = '/bin/pkg'
    system_os_macos   = '/opt/homebrew/bin/brew'
    supported_system_os = [system_os_debian, system_os_redhat, system_os_freebsd, system_os_macos]

    for supported_os in supported_system_os:
        if os.path.exists(supported_os):
            system_os = supported_os
    
    if system_os is None:
            logging.critical(f'Error: The Operating System for {system_fqdn} could not be evaluated.')
            sys.exit(2)

    logging.info(f'Info: The Operating System for {system_fqdn} got evaluated and will use {system_os} for security patching.')
    return system_os


def _validate_systems_patch_window(qualvosec_times, system_fqdn):
    """ Validate if the system is in the patch window. """
    execute_patching = True
    for time_now, time_patch in qualvosec_times.items():
        if time_now != time_patch:
            execute_patching = False

    if not execute_patching:
        logging.info(f'Info: The system {system_fqdn} has not yet reached the security patch window.')
    else:
        logging.info(f'Info: The system {system_fqdn} has reached the security patch window and will be patched.')
    return execute_patching


def _execute_patch_system(system_os_pkg_mgmr, system_fqdn):
    """ Execute patching the system. """
    if system_os_pkg_mgmr == '/bin/apt':
        logging.info(f'Info: Using apt-get for patching.')
        process = subprocess.Popen(['sudo', 'apt-get', '-y', 'upgrade'], stderr=subprocess.PIPE, stdout=subprocess.PIPE)

    elif system_os_pkg_mgmr == '/bin/rpm':
        logging.info(f'Info: Using yum for patching.')
        process = subprocess.Popen(['sudo', 'yum', '-y', 'upgrade'], stderr=subprocess.PIPE, stdout=subprocess.PIPE)

    elif system_os_pkg_mgmr == '/bin/pkg':
        logging.info(f'Info: Using pkg for patching.')
        process = subprocess.Popen(['sudo', 'pkg', '-y', 'upgrade'], stderr=subprocess.PIPE, stdout=subprocess.PIPE)

    elif system_os_pkg_mgmr == '/opt/homebrew/bin/brew':
        logging.info(f'Info: Using homebrew for patching.')
        process = subprocess.Popen(['sudo', 'brew', 'upgrade'], stderr=subprocess.PIPE, stdout=subprocess.PIPE)

    process_output, process_error = process.communicate()
    exit_code = process.wait()

    if exit_code != 0:
        logging.critical(f'Error The system {system_fqdn} could not be patched.')
        logging.critical(f'Log: {process_error}')
        sys.exit(2)
    else:
        logging.critical(f'Info: The system {system_fqdn} got successfully patched.')
        logging.info(f'Log: {process_output}')


def _validate_system_reboot(system_fqdn, qualvosec_manifest):
    """ Validate is system should be rebooted after security patching by QualvoSec. """
    if qualvosec_manifest[system_fqdn].get('reboot'):
        return True


def _execute_reboot_system(system_fqdn):
    """ Reboot the system after security patching by QualvoSec. """
    process = subprocess.Popen(['sudo', 'reboot'], stderr=subprocess.PIPE, stdout=subprocess.PIPE)
    process_output, process_error = process.communicate()
    exit_code = process.wait()
    if exit_code != 0:
        logging.critical(f'Error The system {system_fqdn} could not be rebooted.')
        logging.critical(f'Log: {process_error}')
        sys.exit(2)
    else:
        logging.critical(f'Info: The system {system_fqdn} will be rebooted now.')
        logging.info(f'Log: {process_output}')


def patch_system(system_fqdn, qualvosec_manifest):
    """ Run the basic patch routine to integrate security fixes by QualvoSec. """
    # Validate that the system is present in the manifest.
    if not qualvosec_manifest.get(system_fqdn):
        logging.critical(f'Error: The system {system_fqdn} could not be found in the QualvoSec manifest.')
        sys.exit(2)

    # Validate that the system should be patched.
    if not qualvosec_manifest[system_fqdn].get('patch'):
        logging.warning(f'Warning: The system {system_fqdn} is not activated for security patching.')
        sys.exit(1)
    
    # Compare time slots for a matching time window.
    qualvosec_times = {}
    weekday_now,   hour_now,   minute_now   = _get_time_information_now()
    weekday_patch, hour_patch, minute_patch = _get_time_information_patch(system_fqdn, qualvosec_manifest)
    
    qualvosec_times[weekday_now] = weekday_patch
    qualvosec_times[hour_now]    = hour_patch
    qualvosec_times[minute_now]  = minute_patch

    # Check for patch window.
    execute_patching = _validate_systems_patch_window(qualvosec_times, system_fqdn)
    logging.info(f'Info: The system {system_fqdn} is in state execute_patching: {execute_patching}')

    # Execute patching.
    if execute_patching:
        system_os_pkg_mgmr = _get_system_os_pkg_mgr(system_fqdn)
        _execute_patch_system(system_os_pkg_mgmr, system_fqdn)
        system_reboot_state = _validate_system_reboot(system_fqdn, qualvosec_manifest)
        if system_reboot_state:
            _execute_reboot_system(system_fqdn)


def main():
    """ Run QualvoSec - A minimalistic security patch management tool. """
    qualvosec_manifest_path = None
    global monitoring_port
    app_args = initialize_args()
    config_path = initialize_config_path(app_args)
    server, log_level, log_handler, monitoring, monitoring_port = initialize_config_options(config_path)
    initialize_logger(log_level, log_handler)
    if monitoring:
        threading.Thread(target=initialize_monitoring, name="monitoring").start()

    while True:
        system_fqdn = get_system_fqdn()
        qualvosec_manifest_path = fetch_qualvosec_manifest(server, qualvosec_manifest_path, system_fqdn)
        qualvosec_manifest = read_qualvosec_manifest(qualvosec_manifest_path[0])
        patch_system(system_fqdn, qualvosec_manifest)
        # Recheck after 50 seconds
        time.sleep(float(50))


if __name__ == '__main__':
    main()
